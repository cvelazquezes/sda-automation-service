---
description: Automation Service specific patterns - browser automation
globs: "automation-service/**/*.py"
alwaysApply: false
---

# Automation Service Rules

## Browser Context Management

### Always Use Context Manager
```python
async def extract_with_browser(request: ScrapeRequest) -> dict:
    async with async_playwright() as p:
        browser = await p.chromium.launch(
            headless=settings.BROWSER_HEADLESS,
            args=['--no-sandbox', '--disable-setuid-sandbox']
        )
        context = await browser.new_context(
            user_agent=get_random_user_agent(),
            viewport={'width': 1920, 'height': 1080},
            locale='es-ES'
        )
        page = await context.new_page()

        try:
            result = await perform_extraction(page, request)
            return result
        finally:
            await context.close()
            await browser.close()
```

### Resource Limiting
```python
from asyncio import Semaphore

MAX_CONCURRENT_BROWSERS = 5
browser_semaphore = Semaphore(MAX_CONCURRENT_BROWSERS)

async def safe_extract(request: ScrapeRequest) -> dict:
    async with browser_semaphore:
        return await extract_with_browser(request)
```

## Page Interaction Patterns

### Wait for Elements
```python
async def wait_and_click(page: Page, selector: str, timeout: int = 30000):
    """Wait for element and click it."""
    await page.wait_for_selector(selector, timeout=timeout)
    await page.click(selector)

async def wait_and_fill(page: Page, selector: str, value: str, timeout: int = 30000):
    """Wait for element and fill it."""
    await page.wait_for_selector(selector, timeout=timeout)
    await page.fill(selector, value)
```

### Handle Navigation
```python
async def navigate_and_wait(page: Page, url: str) -> None:
    """Navigate and wait for network idle."""
    await page.goto(url, wait_until='networkidle', timeout=60000)
```

## Login Flow

```python
async def login(page: Page, username: str, password: str) -> bool:
    """Perform login with retry logic."""
    try:
        # Navigate to login page
        await page.goto(LOGIN_URL, wait_until='networkidle')

        # Fill credentials
        await page.fill('#username', username)
        await page.fill('#password', password)

        # Submit form
        await page.click('#login-button')

        # Wait for redirect or error
        try:
            await page.wait_for_url('**/dashboard**', timeout=10000)
            return True
        except TimeoutError:
            # Check for error message
            error = await page.query_selector('.error-message')
            if error:
                raise LoginFailedError(await error.text_content())
            raise

    except PlaywrightError as e:
        logger.error('login_failed', error=str(e))
        raise LoginFailedError(str(e))
```

## Data Extraction

### Base Extractor Pattern
```python
class BaseExtractor(ABC):
    def __init__(self, page: Page):
        self.page = page

    @abstractmethod
    async def extract(self) -> dict:
        """Extract data from page."""
        pass

    async def safe_get_text(self, selector: str) -> Optional[str]:
        """Safely get text content."""
        try:
            element = await self.page.query_selector(selector)
            if element:
                return (await element.text_content()).strip()
        except Exception:
            pass
        return None

    async def safe_get_all_text(self, selector: str) -> List[str]:
        """Get text from all matching elements."""
        elements = await self.page.query_selector_all(selector)
        texts = []
        for el in elements:
            text = await el.text_content()
            if text:
                texts.append(text.strip())
        return texts
```

### Profile Extractor
```python
class ProfileExtractor(BaseExtractor):
    async def extract(self) -> dict:
        return {
            'name': await self.safe_get_text('.profile-name'),
            'club': await self.safe_get_text('.club-name'),
            'class': await self.safe_get_text('.pathfinder-class'),
            'role': await self.safe_get_text('.member-role'),
        }
```

## Error Handling

```python
class AutomationError(Exception):
    """Base automation error."""
    def __init__(self, message: str, details: dict = None):
        self.message = message
        self.details = details or {}
        super().__init__(message)

class LoginFailedError(AutomationError):
    """Login failed."""
    pass

class ExtractionError(AutomationError):
    """Data extraction failed."""
    pass

class TimeoutError(AutomationError):
    """Operation timed out."""
    pass
```

## Retry Logic

```python
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type

@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=2, max=10),
    retry=retry_if_exception_type((TimeoutError, ConnectionError))
)
async def extract_with_retry(page: Page, extractor: BaseExtractor) -> dict:
    return await extractor.extract()
```

## Structured Logging

```python
import structlog

logger = structlog.get_logger()

async def extract_profile(request: ScrapeRequest) -> dict:
    logger.info('extraction_started',
                user_id=str(request.user_id),
                extraction_type='profile')

    try:
        result = await perform_extraction(request)
        logger.info('extraction_completed',
                    user_id=str(request.user_id),
                    duration_ms=result['duration_ms'])
        return result
    except Exception as e:
        logger.error('extraction_failed',
                     user_id=str(request.user_id),
                     error=str(e))
        raise
```

## Testing

```python
import pytest
from playwright.async_api import async_playwright

@pytest.mark.asyncio
async def test_profile_extraction():
    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=True)
        page = await browser.new_page()

        # Load test HTML
        await page.set_content(TEST_PROFILE_HTML)

        extractor = ProfileExtractor(page)
        result = await extractor.extract()

        assert result['name'] == 'Test User'
        assert result['club'] == 'Test Club'

        await browser.close()
```
